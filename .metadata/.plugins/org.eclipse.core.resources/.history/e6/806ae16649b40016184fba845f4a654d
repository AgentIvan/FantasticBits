import java.util.List;

class Entity {
	private int id;
	private Point point;
	private int vx;
	private int vy;
	private int state;
	
	public Entity(int x, int y) {
		super();
		point = new Point(x,y);
	}
	
	public Entity(int id, int x, int y, int vx, int vy) {
		this(x, y);
		this.id = id;
		this.vx = vx;
		this.vy = vy;
	}
	
	public Entity(int id, int x, int y, int vx, int vy, int state) {
		this(id, x, y, vx, vy);
		this.state = state;
	}

	public int getState() {
		return state;
	}

	public void setState(int state) {
		this.state = state;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getX() {
		return point.getX();
	}

	public void setX(int x) {
		point.setX(x);
	}

	public int getY() {
		return point.getY();
	}

	public void setY(int y) {
		point.setY(y);
	}

	public int getVx() {
		return vx;
	}

	public void setVx(int vx) {
		this.vx = vx;
	}

	public int getVy() {
		return vy;
	}

	public void setVy(int vy) {
		this.vy = vy;
	}
	
	public Entity searchNearestSnaffle(List<Entity> snaffles) {
		int minDistance = Integer.MAX_VALUE;
		Entity nearestEntity = null;
		
		for(Entity snaffle : snaffles) {
			int newDistance = computeDistanceSquare(snaffle);
			if(newDistance < minDistance) {
				minDistance = newDistance;
				nearestEntity = snaffle;
			}
		}
		
		return nearestEntity;
	}
	
	public int computeDistanceSquare(Entity entity) {
		return (this.getX()-entity.getX())*(this.getX()-entity.getX()) + (this.getY()-entity.getY())*(this.getY()-entity.getY());
	}
	
	
	public boolean isUsefulToAccio(Entity entity, Entity goal) {
		if(isBetweenInX(entity, goal) && computeDistanceSquare(entity)>4000000) {
			return true;
		}
		return false;
	}
	
	/*
	 * Return true if current entity is between the two other in axis X
	 */
	public boolean isBetweenInX(Entity entity1, Entity entity2) {
		if(entity1.getX()<this.getX() && entity2.getX() > this.getX()) {
			return true;
		}
		if(entity1.getX()>this.getX() && entity2.getX() < this.getX()) {
			return true;
		}
		return false;
	}
	
}
