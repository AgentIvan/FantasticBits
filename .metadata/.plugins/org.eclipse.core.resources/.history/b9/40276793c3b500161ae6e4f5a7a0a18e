import java.util.List;

class Entity {
	private int id;
	private Point point;
	private int vx;
	private int vy;
	private int state;
	private double friction;
	private int radius;
	private int type; //0 for wizards, 1 for snaffles
	
	public Entity(int x, int y) {
		super();
		point = new Point(x,y);
	}
	
	public Entity(int id, int x, int y, int vx, int vy) {
		this(x, y);
		this.id = id;
		this.vx = vx;
		this.vy = vy;
	}
	
	public Entity(int id, int x, int y, int vx, int vy, int state) {
		this(id, x, y, vx, vy);
		this.state = state;
	}
	
	public Entity(int id, int x, int y, int vx, int vy, int state, double friction, int radius, int type) {
		this(id, x, y, vx, vy);
		this.state = state;
		this.friction = friction;
		this.radius = radius;
		this.type = type;
	}
	

	public int getState() {
		return state;
	}

	public void setState(int state) {
		this.state = state;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getX() {
		return point.getX();
	}

	public void setX(int x) {
		point.setX(x);
	}

	public int getY() {
		return point.getY();
	}

	public void setY(int y) {
		point.setY(y);
	}

	public int getVx() {
		return vx;
	}

	public void setVx(int vx) {
		this.vx = vx;
	}

	public int getVy() {
		return vy;
	}

	public void setVy(int vy) {
		this.vy = vy;
	}
	
	public Entity searchNearestSnaffle(List<Entity> snaffles) {
		int minDistance = Integer.MAX_VALUE;
		Entity nearestEntity = null;
		
		for(Entity snaffle : snaffles) {
			int newDistance = computeDistanceSquare(snaffle);
			if(newDistance < minDistance) {
				minDistance = newDistance;
				nearestEntity = snaffle;
			}
		}
		
		return nearestEntity;
	}
	
	/**
	 * Search nearest snaffle except the snaffle with input id
	 * @param snaffles
	 * @param id
	 * @return
	 */
	public Entity searchNearestSnaffleExcept(List<Entity> snaffles, int id) {
		int minDistance = Integer.MAX_VALUE;
		Entity nearestEntity = null;
		
		for(Entity snaffle : snaffles) {
			int newDistance = computeDistanceSquare(snaffle);
			if(snaffle.getId()!=id && newDistance < minDistance) {
				minDistance = newDistance;
				nearestEntity = snaffle;
			}
		}
		
		return nearestEntity;
	}
	
	public int computeDistanceSquare(Entity entity) {
		return (this.getX()-entity.getX())*(this.getX()-entity.getX()) + (this.getY()-entity.getY())*(this.getY()-entity.getY());
	}
	
	
	public boolean isUsefulToAccio(Entity entity, Entity goal) {
		if(point.isBetweenInX(entity.getPoint(), goal.getPoint()) && computeDistanceSquare(entity)>4000000) {
			return true;
		}
		return false;
	}
	

	public Point getPoint() {
		return point;
	}

	public void setPoint(Point point) {
		this.point = point;
	}
	
	// DEPRECATED !!!!
	/*private Point computeNextPosition(int customVx, int customVy) {
		int newX = this.getX() + customVx;
		int newY = this.getY() + customVy;
		

		
		//TODO: Check collision with wall (impulsion)
		if(newX + radius >16000) {
			newX = 2*16000 -2*radius - newX;
		} else {
			if(newX - radius<0) {
				newX = 2*radius -newX;
			}
		}
		
		//TODO: Check collision with wall (impulsion)
		if(newY + radius >7500) {
			newY = 2*7500 -2*radius - newY;
		} else {
			if(newY - radius<0) {
				newY = 2*radius -newY;
			}
		}
		
		Point newPosition = new Point(newX, newY);
		return newPosition;
	}*/
	
	
	public Point computeNextPositionInNbTour(int nbTour) {
		int tempX = this.getX();
		int tempY = this.getY();
		int tempVx = this.vx;
		int tempVy = this.vy;
		
		for(int i=0; i<nbTour; i++) {
			
			tempX += tempVx;
			tempY += tempVy;
			
			//TODO: Check collision with wall (impulsion)
			if(tempX + radius >16000) {
				if(this.type == 1 && this.isInGoal(tempX))
				tempX = 2*16000 -2*radius - tempX;
				tempVx = -tempVx;
			} else {
				if(tempX - radius<0) {
					tempX = 2*radius -tempX;
					tempVx = -tempVx;
				}
			}
			
			//TODO: Check collision with wall (impulsion)
			if(tempY + radius >7500) {
				tempY = 2*7500 -2*radius - tempY;
				tempVy = -tempVy;
			} else {
				if(tempY - radius<0) {
					tempY = 2*radius -tempY;
					tempVy = -tempVy;
				}
			}
			
			tempVx = (int) (tempVx * friction);
			tempVy = (int) (tempVy * friction);
			
		}
		

		
		Point newPosition = new Point(tempX, tempY);
		return newPosition;
	}
	
	public boolean isInGoal(int py) {
		if(py>1900 && py<5600) {
			return true;
		}
		
		return false;
	}
	
	public void stop() {
		this.vx = 0;
		this.vy = 0;
	}
}
